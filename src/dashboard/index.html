<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NEXUS Command Center</title>
<link rel="icon" type="image/svg+xml" href="/dashboard/logo.svg">
<link rel="apple-touch-icon" href="/dashboard/logo.svg">
<meta name="description" content="NEXUS — Autonomous AI Engineering Organization Dashboard">
<meta property="og:title" content="NEXUS Command Center">
<meta property="og:description" content="Real-time orchestration dashboard for an autonomous AI engineering org">
<meta property="og:type" content="website">
<style>
  :root {
    --bg: #0a0a1a; --surface: #12122a; --border: #1e1e3a;
    --text: #e0e0f0; --dim: #8888aa; --accent: #00D2FF;
    --secondary: #7B61FF; --success: #00E676; --warning: #FFD740;
    --danger: #FF5252; --radius: 10px;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'SF Mono', 'Fira Code', monospace; background: var(--bg); color: var(--text); min-height: 100vh; }

  /* Accessibility - Focus indicators */
  *:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* Mobile responsive */
  @media (max-width: 768px) {
    .header {
      flex-direction: column;
      gap: 12px;
      padding: 16px 20px;
    }
    .grid {
      grid-template-columns: 1fr;
      padding: 16px 20px;
    }
    .card[style*="grid-column"] {
      grid-column: 1 !important;
    }
  }

  .header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 20px 32px; border-bottom: 1px solid var(--border);
  }
  .header h1 { font-size: 24px; letter-spacing: 4px; color: var(--accent); }
  .header .status { display: flex; align-items: center; gap: 8px; }
  .header .dot { width: 10px; height: 10px; border-radius: 50%; background: var(--success); animation: pulse 2s infinite; }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

  .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 16px; padding: 24px 32px; }

  .card {
    background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
    overflow: hidden; transition: border-color 0.2s;
  }
  .card:hover { border-color: var(--accent); }
  .card-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 16px 20px; cursor: pointer; user-select: none;
    width: 100%; background: transparent; border: none; color: inherit; font: inherit;
    text-align: left;
  }
  .card-header:hover { background: rgba(255,255,255,0.02); }
  .card-header:active { background: rgba(255,255,255,0.04); }
  .card-header h2 { font-size: 14px; text-transform: uppercase; letter-spacing: 2px; color: var(--dim); }
  .card-summary { font-size: 28px; font-weight: bold; color: var(--accent); }
  .card-body { padding: 0 20px 16px; display: none; }
  .card.expanded .card-body { display: block; }
  .card-header .chevron { transition: transform 0.2s; color: var(--dim); }
  .card.expanded .card-header .chevron { transform: rotate(180deg); }

  table { width: 100%; border-collapse: collapse; font-size: 13px; }
  th { text-align: left; color: var(--dim); padding: 8px 0; border-bottom: 1px solid var(--border); font-weight: normal; text-transform: uppercase; letter-spacing: 1px; font-size: 11px; }
  td { padding: 8px 0; border-bottom: 1px solid var(--border); }

  .badge {
    display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;
  }
  .badge-ok { background: rgba(0,230,118,0.15); color: var(--success); }
  .badge-warn { background: rgba(255,215,64,0.15); color: var(--warning); }
  .badge-err { background: rgba(255,82,82,0.15); color: var(--danger); }
  .badge-idle { background: rgba(136,136,170,0.15); color: var(--dim); }

  .event-log { max-height: 300px; overflow-y: auto; font-size: 12px; }

  /* Screen reader only class */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0,0,0,0);
    white-space: nowrap;
    border-width: 0;
  }
  .event-row { display: flex; gap: 12px; padding: 6px 0; border-bottom: 1px solid var(--border); align-items: center; }
  .event-time { color: var(--dim); flex-shrink: 0; width: 60px; }
  .event-source { color: var(--secondary); flex-shrink: 0; width: 100px; }
  .event-cli-badge {
    display: inline-block; padding: 1px 6px; border-radius: 3px; font-size: 10px;
    background: rgba(0,210,255,0.12); color: var(--accent); cursor: pointer;
    border: 1px solid rgba(0,210,255,0.25); margin-left: 6px; font-family: monospace;
    white-space: nowrap;
  }
  .event-cli-badge:hover { background: rgba(0,210,255,0.25); border-color: var(--accent); }

  .circuit-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; }
  .circuit-chip {
    padding: 8px 12px; border-radius: 6px; text-align: center; font-size: 12px;
    border: 1px solid var(--border);
  }
  .circuit-closed { border-color: var(--success); color: var(--success); }
  .circuit-open { border-color: var(--danger); color: var(--danger); background: rgba(255,82,82,0.08); }
  .circuit-half_open { border-color: var(--warning); color: var(--warning); }

  .empty { color: var(--dim); font-style: italic; padding: 16px 0; text-align: center; }
  footer { text-align: center; padding: 24px; color: var(--dim); font-size: 12px; }

  /* Login overlay */
  .login-overlay {
    position: fixed; inset: 0; z-index: 9999;
    background: var(--bg);
    display: flex; align-items: center; justify-content: center;
    flex-direction: column; gap: 24px;
  }
  .login-overlay.hidden { display: none; }
  .login-box {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 40px 36px; width: 360px;
    text-align: center;
  }
  .login-box h1 { font-size: 28px; letter-spacing: 6px; color: var(--accent); margin-bottom: 8px; }
  .login-box p { color: var(--dim); font-size: 13px; margin-bottom: 24px; }
  .login-input {
    width: 100%; padding: 12px 16px; border-radius: 8px;
    border: 1px solid var(--border); background: var(--bg);
    color: var(--text); font-family: inherit; font-size: 14px;
    text-align: center; letter-spacing: 2px;
  }
  .login-input:focus { border-color: var(--accent); outline: none; }
  .login-btn {
    width: 100%; padding: 12px; margin-top: 16px; border-radius: 8px;
    border: none; background: linear-gradient(135deg, var(--accent), var(--secondary));
    color: #fff; font-family: inherit; font-weight: bold; font-size: 14px;
    cursor: pointer; letter-spacing: 1px;
  }
  .login-btn:hover { opacity: 0.9; }
  .login-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .login-error {
    color: var(--danger); font-size: 12px; margin-top: 12px;
    min-height: 18px;
  }
  .logout-btn {
    background: none; border: 1px solid var(--border); color: var(--dim);
    padding: 4px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;
    font-family: inherit;
  }
  .logout-btn:hover { border-color: var(--danger); color: var(--danger); }

  /* Settings */
  .settings-btn {
    background: none; border: 1px solid var(--border); color: var(--dim);
    padding: 4px 10px; border-radius: 6px; cursor: pointer; font-size: 14px;
    font-family: inherit; line-height: 1;
  }
  .settings-btn:hover { border-color: var(--accent); color: var(--accent); }
  .settings-modal {
    position: fixed; inset: 0; z-index: 9998;
    background: rgba(0,0,0,0.7); display: none;
    align-items: center; justify-content: center;
  }
  .settings-modal.open { display: flex; }
  .settings-box {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 32px; width: 420px;
  }
  .settings-box h2 { font-size: 16px; color: var(--accent); letter-spacing: 2px; margin-bottom: 20px; }
  .settings-box label { display: block; color: var(--dim); font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
  .settings-box input {
    width: 100%; padding: 10px 14px; border-radius: 6px;
    border: 1px solid var(--border); background: var(--bg);
    color: var(--text); font-family: inherit; font-size: 13px;
    margin-bottom: 16px;
  }
  .settings-box input:focus { border-color: var(--accent); outline: none; }
  .settings-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px; }
  .settings-actions button {
    padding: 8px 18px; border-radius: 6px; border: none;
    font-family: inherit; font-size: 13px; cursor: pointer;
  }
  .settings-save { background: var(--accent); color: #000; font-weight: bold; }
  .settings-cancel { background: var(--border); color: var(--dim); }
  .settings-save:hover { opacity: 0.9; }
  .settings-cancel:hover { color: var(--text); }
  .connection-badge {
    font-size: 10px; padding: 2px 8px; border-radius: 4px;
    text-transform: uppercase; letter-spacing: 1px; font-weight: bold;
  }
  .connection-local { background: rgba(0,230,118,0.15); color: var(--success); }
  .connection-remote { background: rgba(123,97,255,0.15); color: var(--secondary); }
  .connection-offline { background: rgba(255,215,64,0.15); color: var(--warning); }

  /* Session management */
  .session-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 8px 0; border-bottom: 1px solid var(--border);
  }
  .session-info { font-size: 12px; }
  .session-thread { color: var(--accent); font-family: monospace; }
  .session-idle { color: var(--dim); font-size: 11px; }
  .session-kill {
    background: none; border: 1px solid var(--danger); color: var(--danger);
    padding: 4px 10px; border-radius: 4px; cursor: pointer;
    font-size: 11px; font-family: inherit;
  }
  .session-kill:hover { background: rgba(255,82,82,0.15); }
  .kill-all-btn {
    background: none; border: 1px solid var(--danger); color: var(--danger);
    padding: 6px 14px; border-radius: 6px; cursor: pointer;
    font-size: 12px; font-family: inherit; margin-top: 8px;
  }
  .kill-all-btn:hover { background: rgba(255,82,82,0.15); }

  /* Chat panel — slide-out from right */
  .chat-toggle {
    position: fixed; bottom: 24px; right: 24px; z-index: 100;
    width: 56px; height: 56px; border-radius: 50%;
    background: linear-gradient(135deg, var(--accent), var(--secondary));
    border: none; cursor: pointer; color: #fff; font-size: 24px;
    display: flex; align-items: center; justify-content: center;
    box-shadow: 0 4px 20px rgba(0,210,255,0.3);
    transition: transform 0.2s;
  }
  .chat-toggle:hover { transform: scale(1.1); }

  .chat-panel {
    position: fixed; top: 0; right: -420px; width: 420px; height: 100vh;
    background: var(--surface); border-left: 1px solid var(--border);
    z-index: 200; transition: right 0.3s ease;
    display: flex; flex-direction: column;
  }
  .chat-panel.open { right: 0; }

  .chat-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 16px 20px; border-bottom: 1px solid var(--border);
  }
  .chat-header h2 { font-size: 14px; text-transform: uppercase; letter-spacing: 2px; color: var(--accent); }
  .chat-close { background: none; border: none; color: var(--dim); cursor: pointer; font-size: 20px; padding: 4px 8px; }
  .chat-close:hover { color: var(--text); }

  .chat-threads {
    padding: 8px 12px; border-bottom: 1px solid var(--border);
    max-height: 160px; overflow-y: auto;
  }
  .thread-item {
    padding: 8px 12px; border-radius: 6px; cursor: pointer;
    font-size: 12px; color: var(--dim); margin-bottom: 4px;
    border: 1px solid transparent; background: none; width: 100%;
    text-align: left; font-family: inherit;
  }
  .thread-item:hover { background: rgba(255,255,255,0.03); border-color: var(--border); }
  .thread-item.active { border-color: var(--accent); color: var(--text); }
  .thread-count { color: var(--secondary); font-size: 11px; }

  .chat-messages {
    flex: 1; overflow-y: auto; padding: 16px;
    display: flex; flex-direction: column; gap: 12px;
  }
  .msg { max-width: 85%; padding: 10px 14px; border-radius: 10px; font-size: 13px; line-height: 1.5; word-break: break-word; }
  .msg-user { align-self: flex-end; background: var(--accent); color: #0a0a1a; border-bottom-right-radius: 2px; }
  .msg-bot { align-self: flex-start; background: var(--border); color: var(--text); border-bottom-left-radius: 2px; }
  .msg-searching { font-style: italic; color: var(--dim); font-size: 12px; align-self: center; }

  .chat-input-area {
    padding: 12px 16px; border-top: 1px solid var(--border);
    display: flex; gap: 8px;
  }
  .chat-input {
    flex: 1; padding: 10px 14px; border-radius: 8px;
    border: 1px solid var(--border); background: var(--bg);
    color: var(--text); font-family: inherit; font-size: 13px;
    resize: none; min-height: 40px; max-height: 120px;
  }
  .chat-input:focus { border-color: var(--accent); outline: none; }
  .chat-send {
    padding: 10px 16px; border-radius: 8px; border: none;
    background: var(--accent); color: #0a0a1a; cursor: pointer;
    font-family: inherit; font-weight: bold; font-size: 13px;
    align-self: flex-end;
  }
  .chat-send:hover { opacity: 0.9; }
  .chat-send:disabled { opacity: 0.4; cursor: not-allowed; }

  @media (max-width: 768px) {
    .chat-panel { width: 100vw; right: -100vw; }
  }
</style>
</head>
<body>

<!-- Login overlay — shown until authenticated -->
<div id="login-overlay" class="login-overlay">
  <div class="login-box">
    <h1>NEXUS</h1>
    <p>Enter passphrase to access the command center</p>
    <form id="login-form" autocomplete="off">
      <input id="login-input" class="login-input" type="password"
             placeholder="Passphrase" autocomplete="off" required>
      <button id="login-btn" class="login-btn" type="submit">Authenticate</button>
    </form>
    <div id="login-error" class="login-error"></div>
  </div>
</div>

<header class="header" role="banner">
  <h1>NEXUS</h1>
  <div class="status" role="status" aria-live="polite">
    <span id="connection-badge" class="connection-badge connection-local">LOCAL</span>
    <div class="dot" aria-hidden="true"></div>
    <span id="engine-status">Connecting...</span>
    <button id="settings-btn" class="settings-btn" title="Engine settings">&#9881;</button>
    <button id="logout-btn" class="logout-btn" style="display:none;">Logout</button>
  </div>
</header>

<div id="settings-modal" class="settings-modal">
  <div class="settings-box">
    <h2>ENGINE CONNECTION</h2>
    <label for="settings-url">Engine URL</label>
    <input id="settings-url" type="url" placeholder="https://your-tunnel.trycloudflare.com" />
    <p style="color:var(--dim);font-size:11px;margin:-8px 0 16px;">
      Leave blank for local mode (same origin). Set a tunnel URL for remote access.
    </p>
    <div class="settings-actions">
      <button class="settings-cancel" id="settings-cancel">Cancel</button>
      <button class="settings-save" id="settings-save">Save &amp; Reconnect</button>
    </div>
  </div>
</div>

<main class="grid" role="main">
  <div class="card" id="card-directive">
    <button class="card-header" aria-expanded="false" aria-controls="directive-detail">
      <div><h2>Active Directive</h2><div class="card-summary" id="directive-summary">--</div></div>
      <span class="chevron" aria-hidden="true">&#9660;</span>
    </button>
    <div class="card-body" id="directive-detail" role="region" aria-labelledby="directive-summary"></div>
  </div>

  <div class="card" id="card-agents">
    <button class="card-header" aria-expanded="false" aria-controls="agents-detail">
      <div><h2>Agents</h2><div class="card-summary" id="agents-summary">--</div></div>
      <span class="chevron" aria-hidden="true">&#9660;</span>
    </button>
    <div class="card-body" id="agents-detail" role="region" aria-labelledby="agents-summary"></div>
  </div>

  <div class="card" id="card-cost">
    <button class="card-header" aria-expanded="false" aria-controls="cost-detail">
      <div><h2>Cost</h2><div class="card-summary" id="cost-summary">--</div></div>
      <span class="chevron" aria-hidden="true">&#9660;</span>
    </button>
    <div class="card-body" id="cost-detail" role="region" aria-labelledby="cost-summary"></div>
  </div>

  <div class="card" id="card-health">
    <button class="card-header" aria-expanded="false" aria-controls="health-detail">
      <div><h2>Health</h2><div class="card-summary" id="health-summary">--</div></div>
      <span class="chevron" aria-hidden="true">&#9660;</span>
    </button>
    <div class="card-body" id="health-detail" role="region" aria-labelledby="health-summary"></div>
  </div>

  <div class="card" id="card-circuits">
    <button class="card-header" aria-expanded="false" aria-controls="circuits-detail">
      <div><h2>Circuit Breakers</h2><div class="card-summary" id="circuits-summary">--</div></div>
      <span class="chevron" aria-hidden="true">&#9660;</span>
    </button>
    <div class="card-body" id="circuits-detail" role="region" aria-labelledby="circuits-summary"></div>
  </div>

  <div class="card" id="card-escalations">
    <button class="card-header" aria-expanded="false" aria-controls="escalations-detail">
      <div><h2>Escalations</h2><div class="card-summary" id="escalations-summary">0</div></div>
      <span class="chevron" aria-hidden="true">&#9660;</span>
    </button>
    <div class="card-body" id="escalations-detail" role="region" aria-labelledby="escalations-summary"></div>
  </div>

  <div class="card" id="card-sessions">
    <button class="card-header" aria-expanded="false" aria-controls="sessions-detail">
      <div><h2>CLI Sessions</h2><div class="card-summary" id="sessions-summary">0</div></div>
      <span class="chevron" aria-hidden="true">&#9660;</span>
    </button>
    <div class="card-body" id="sessions-detail" role="region" aria-labelledby="sessions-summary"></div>
  </div>

  <div class="card expanded" id="card-events" style="grid-column: 1 / -1;">
    <button class="card-header" aria-expanded="true" aria-controls="event-log-container">
      <div><h2>Live Events</h2><div class="card-summary" id="events-summary">0</div></div>
      <span class="chevron" aria-hidden="true">&#9660;</span>
    </button>
    <div class="card-body" id="event-log-container" role="region" aria-labelledby="events-summary">
      <div class="event-log" id="event-log" aria-live="polite" aria-atomic="false"></div>
    </div>
  </div>
</main>

<footer role="contentinfo">NEXUS v3.0 &mdash; Autonomous AI Organization Platform</footer>

<!-- Chat toggle button -->
<button id="chat-toggle" class="chat-toggle" aria-label="Open chat">&#9993;</button>

<!-- Chat slide-out panel -->
<div id="chat-panel" class="chat-panel" role="complementary" aria-label="Chat">
  <div class="chat-header">
    <h2>Threads</h2>
    <button id="chat-close" class="chat-close" aria-label="Close chat">&times;</button>
  </div>
  <div id="thread-list" class="chat-threads"></div>
  <div id="chat-messages" class="chat-messages" aria-live="polite"></div>
  <div class="chat-input-area">
    <textarea id="chat-input" class="chat-input" placeholder="Send a message..." rows="1"></textarea>
    <button id="chat-send" class="chat-send">Send</button>
  </div>
</div>

<script>
// Engine URL: configurable via settings panel (stored in localStorage)
// Priority: localStorage > window.__NEXUS_API_URL__ > same origin
function getEngineUrl() {
  return localStorage.getItem('nexus_engine_url') || window.__NEXUS_API_URL__ || '';
}
function isRemoteMode() {
  const url = getEngineUrl();
  return url && url !== window.location.origin;
}
let API = getEngineUrl() || window.location.origin;
let authToken = localStorage.getItem('nexus_auth_token') || '';

let eventCount = 0;
let currentSSE = null;
let abortController = null;
let isAuthenticated = false;

// ---------------------------------------------------------------------------
// Connection badge
// ---------------------------------------------------------------------------
function updateConnectionBadge() {
  const badge = document.getElementById('connection-badge');
  if (offlineMode) {
    badge.className = 'connection-badge connection-offline';
    badge.textContent = 'OFFLINE';
  } else if (isRemoteMode()) {
    badge.className = 'connection-badge connection-remote';
    badge.textContent = 'REMOTE';
  } else {
    badge.className = 'connection-badge connection-local';
    badge.textContent = 'LOCAL';
  }
}

// ---------------------------------------------------------------------------
// Settings panel
// ---------------------------------------------------------------------------
document.getElementById('settings-btn').addEventListener('click', () => {
  document.getElementById('settings-url').value = getEngineUrl();
  document.getElementById('settings-modal').classList.add('open');
});
document.getElementById('settings-cancel').addEventListener('click', () => {
  document.getElementById('settings-modal').classList.remove('open');
});
document.getElementById('settings-modal').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) e.currentTarget.classList.remove('open');
});
document.getElementById('settings-save').addEventListener('click', () => {
  const url = document.getElementById('settings-url').value.trim().replace(/\/+$/, '');
  if (url) {
    localStorage.setItem('nexus_engine_url', url);
  } else {
    localStorage.removeItem('nexus_engine_url');
  }
  // Clear old auth state when switching engines
  localStorage.removeItem('nexus_auth_token');
  authToken = '';
  API = url || window.location.origin;
  document.getElementById('settings-modal').classList.remove('open');
  // Re-auth against new engine
  isAuthenticated = false;
  if (currentSSE) { currentSSE.close(); currentSSE = null; }
  if (refreshInterval) clearInterval(refreshInterval);
  initAuth();
});

// ---------------------------------------------------------------------------
// Auth — check session before loading dashboard data
// ---------------------------------------------------------------------------

// Offline fallback: when engine is unreachable, verify passphrase client-side
const OFFLINE_HASH = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';
let offlineMode = false;

async function sha256(text) {
  const data = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function checkAuth() {
  try {
    const opts = {credentials: 'same-origin'};
    if (isRemoteMode() && authToken) {
      opts.headers = {'Authorization': 'Bearer ' + authToken};
      opts.credentials = 'omit';
    }
    const resp = await fetch(API + '/auth/check', opts);
    if (resp.status === 404 || resp.status === 405) throw new Error('static host');
    const data = await resp.json();
    offlineMode = false;
    return data.authenticated === true;
  } catch {
    // If we have a stored token but engine is down, stay authenticated
    if (authToken && isRemoteMode()) {
      offlineMode = true;
      return true;
    }
    offlineMode = true;
    return sessionStorage.getItem('nexus_auth') === 'true';
  }
}

async function initAuth() {
  isAuthenticated = await checkAuth();
  updateConnectionBadge();
  const overlay = document.getElementById('login-overlay');
  const logoutBtn = document.getElementById('logout-btn');

  if (isAuthenticated) {
    overlay.classList.add('hidden');
    logoutBtn.style.display = '';
    startDashboard();
  } else {
    overlay.classList.remove('hidden');
    logoutBtn.style.display = 'none';
    document.getElementById('login-input').focus();
  }
}

document.getElementById('login-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  const input = document.getElementById('login-input');
  const btn = document.getElementById('login-btn');
  const errEl = document.getElementById('login-error');
  const passphrase = input.value.trim();
  if (!passphrase) return;

  btn.disabled = true;
  errEl.textContent = '';

  try {
    let ok = false;

    try {
      const loginOpts = {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({passphrase}),
        credentials: isRemoteMode() ? 'omit' : 'same-origin',
      };
      const resp = await fetch(API + '/auth/login', loginOpts);
      if (resp.status === 405 || resp.status === 404) {
        throw new Error('static host');
      }
      if (resp.ok) {
        const data = await resp.json();
        // Save token for remote/cross-origin auth
        if (data.token) {
          authToken = data.token;
          localStorage.setItem('nexus_auth_token', authToken);
        }
        ok = true;
      }
      offlineMode = false;
    } catch {
      offlineMode = true;
      const hash = await sha256(passphrase);
      ok = (hash === OFFLINE_HASH);
      if (ok) sessionStorage.setItem('nexus_auth', 'true');
    }

    if (ok) {
      input.value = '';
      isAuthenticated = true;
      document.getElementById('login-overlay').classList.add('hidden');
      document.getElementById('logout-btn').style.display = '';
      startDashboard();
    } else {
      errEl.textContent = 'Invalid passphrase';
      input.value = '';
      input.focus();
    }
  } catch {
    errEl.textContent = 'Connection error';
  } finally {
    btn.disabled = false;
  }
});

document.getElementById('logout-btn').addEventListener('click', async () => {
  try {
    const logoutOpts = {method: 'POST', credentials: 'same-origin'};
    if (isRemoteMode() && authToken) {
      logoutOpts.headers = {'Authorization': 'Bearer ' + authToken};
      logoutOpts.credentials = 'omit';
    }
    await fetch(API + '/auth/logout', logoutOpts);
  } catch { /* best effort */ }
  sessionStorage.removeItem('nexus_auth');
  localStorage.removeItem('nexus_auth_token');
  authToken = '';
  isAuthenticated = false;
  if (currentSSE) { currentSSE.close(); currentSSE = null; }
  if (refreshInterval) clearInterval(refreshInterval);
  document.getElementById('login-overlay').classList.remove('hidden');
  document.getElementById('logout-btn').style.display = 'none';
  document.getElementById('login-input').focus();
});

function toggle(event) {
  const button = event.currentTarget;
  const card = button.closest('.card');
  const isExpanded = card.classList.contains('expanded');

  card.classList.toggle('expanded');
  button.setAttribute('aria-expanded', !isExpanded);
}

function el(tag, attrs, children) {
  const e = document.createElement(tag);
  if (attrs) Object.entries(attrs).forEach(([k, v]) => {
    if (k === 'class') e.className = v;
    else if (k === 'style') e.style.cssText = v;
    else e.setAttribute(k, v);
  });
  if (typeof children === 'string') e.textContent = children;
  else if (Array.isArray(children)) children.forEach(c => { if (c) e.appendChild(c); });
  return e;
}

function badge(text, type) {
  return el('span', {class: `badge badge-${type}`}, text);
}

function buildTable(headers, rows) {
  const table = el('table');
  const thead = el('tr', null, headers.map(h => el('th', null, h)));
  table.appendChild(thead);
  rows.forEach(cells => {
    const tr = el('tr', null, cells.map(c => {
      const td = el('td');
      if (c instanceof HTMLElement) td.appendChild(c);
      else td.textContent = String(c);
      return td;
    }));
    table.appendChild(tr);
  });
  return table;
}

function clear(id) { document.getElementById(id).replaceChildren(); }

async function fetchJSON(path) {
  try {
    if (abortController) abortController.abort();
    abortController = new AbortController();
    const opts = {signal: abortController.signal, credentials: 'same-origin'};
    if (isRemoteMode() && authToken) {
      opts.headers = {'Authorization': 'Bearer ' + authToken};
      opts.credentials = 'omit';
    }
    const resp = await fetch(API + path, opts);
    if (resp.status === 401) {
      // Session expired or invalid — show login
      isAuthenticated = false;
      if (currentSSE) { currentSSE.close(); currentSSE = null; }
      document.getElementById('login-overlay').classList.remove('hidden');
      document.getElementById('logout-btn').style.display = 'none';
      return null;
    }
    return await resp.json();
  }
  catch (err) {
    if (err.name !== 'AbortError') console.error('Fetch error:', err);
    return null;
  }
}

async function refreshState() {
  const [state, agents, directive, cost, health, metricsHealth, sessions] = await Promise.all([
    fetchJSON('/state'), fetchJSON('/agents'), fetchJSON('/directive'),
    fetchJSON('/cost'), fetchJSON('/health'), fetchJSON('/metrics/health'),
    fetchJSON('/sessions'),
  ]);

  if (health) {
    const running = health.engine_running;
    document.getElementById('engine-status').textContent = running ? 'Engine Online' : 'Engine Offline';
    document.querySelector('.dot').style.background = running ? 'var(--success)' : 'var(--danger)';
    document.getElementById('health-summary').textContent = running ? 'OK' : 'DOWN';

    const rows = [
      ['Engine', running ? badge('Running', 'ok') : badge('Stopped', 'err')],
      ['Active Agents', String(health.working_agents || 0)],
      ['Total Agents', String(health.agents || 0)],
    ];
    if (health.resilience) {
      rows.push(['Uptime', Math.round(health.resilience.uptime_seconds || 0) + 's']);
      rows.push(['Health Checks', String(health.resilience.check_count || 0)]);
      rows.push(['Dead Letter Queue', String(health.resilience.dead_letter_depth || 0)]);
    }
    const container = document.getElementById('health-detail');
    container.replaceChildren(buildTable(['Metric', 'Value'], rows));
  }

  if (directive) {
    const d = directive.directive;
    const container = document.getElementById('directive-detail');
    if (d) {
      document.getElementById('directive-summary').textContent = d.status || 'active';
      const frag = document.createDocumentFragment();
      frag.appendChild(el('p', {style: 'margin-bottom:12px;color:var(--text)'}, d.text || '--'));
      if (directive.task_board && directive.task_board.length) {
        const rows = directive.task_board.map(t => {
          const st = t.status === 'completed' ? 'ok' : t.status === 'failed' ? 'err' : 'idle';
          return [(t.description||'').substring(0,60), badge(t.status, st), t.assigned_to||'--'];
        });
        frag.appendChild(buildTable(['Task', 'Status', 'Agent'], rows));
      }
      container.replaceChildren(frag);
    } else {
      document.getElementById('directive-summary').textContent = 'Idle';
      container.replaceChildren(el('div', {class: 'empty'}, 'No active directive'));
    }
  }

  if (agents) {
    const list = agents.agents || [];
    const working = list.filter(a => a.status === 'working' || a.status === 'thinking').length;
    document.getElementById('agents-summary').textContent = working + ' / ' + list.length;
    const rows = list.slice(0, 20).map(a => {
      const st = a.status === 'working' ? 'ok' : a.status === 'thinking' ? 'warn' : 'idle';
      return [a.name || a.agent_id, badge(a.status, st), (a.last_action||'--').substring(0,40)];
    });
    document.getElementById('agents-detail').replaceChildren(buildTable(['Agent', 'Status', 'Last Action'], rows));
  }

  if (cost) {
    const total = cost.total_cost_usd || cost.total || 0;
    const rate = cost.hourly_rate || 0;
    document.getElementById('cost-summary').textContent = '$' + total.toFixed(2);
    const rows = [['Total Spend', '$' + total.toFixed(2)], ['Hourly Rate', '$' + rate.toFixed(2) + '/hr']];
    if (cost.by_model) {
      Object.entries(cost.by_model).forEach(([m, c]) => rows.push([m, '$' + Number(c).toFixed(3)]));
    }
    document.getElementById('cost-detail').replaceChildren(buildTable(['Metric', 'Value'], rows));
  }

  if (metricsHealth) {
    const circuits = metricsHealth.circuits || [];
    const openCount = circuits.filter(c => c.state === 'open').length;
    document.getElementById('circuits-summary').textContent = openCount > 0 ? openCount + ' OPEN' : circuits.length > 0 ? circuits.length + ' OK' : '--';

    const circuitContainer = document.getElementById('circuits-detail');
    if (circuits.length) {
      const grid = el('div', {class: 'circuit-grid'});
      circuits.forEach(c => {
        const chip = el('div', {class: 'circuit-chip circuit-' + c.state});
        chip.appendChild(el('span', null, c.name));
        chip.appendChild(document.createElement('br'));
        chip.appendChild(el('small', null, c.state));
        grid.appendChild(chip);
      });
      circuitContainer.replaceChildren(grid);
    } else {
      circuitContainer.replaceChildren(el('div', {class: 'empty'}, 'No circuits registered'));
    }

    const esc = metricsHealth.escalation || {};
    document.getElementById('escalations-summary').textContent = String(esc.total_escalations || 0);
    const recent = esc.recent_escalations || [];
    const escContainer = document.getElementById('escalations-detail');
    if (recent.length) {
      const rows = recent.map(e => [e.id, e.agent, e.reason]);
      escContainer.replaceChildren(buildTable(['ID', 'Agent', 'Reason'], rows));
    } else {
      escContainer.replaceChildren(el('div', {class: 'empty'}, 'No escalations'));
    }
  }

  // CLI Sessions
  if (sessions) {
    const list = sessions.sessions || [];
    const active = sessions.active_sessions || 0;
    document.getElementById('sessions-summary').textContent = active > 0 ? active + ' active' : '0';

    const container = document.getElementById('sessions-detail');
    if (list.length) {
      const frag = document.createDocumentFragment();
      for (const s of list) {
        const row = el('div', {class: 'session-row'});
        const info = el('div', {class: 'session-info'});
        info.appendChild(el('span', {class: 'session-thread'}, s.thread_ts));
        info.appendChild(document.createTextNode(' '));
        const idleMin = Math.round(s.idle_seconds / 60);
        info.appendChild(el('span', {class: 'session-idle'},
          s.alive ? `idle ${idleMin}m` : 'dead'));
        row.appendChild(info);

        const killBtn = el('button', {class: 'session-kill'}, 'Terminate');
        killBtn.addEventListener('click', async () => {
          killBtn.disabled = true;
          killBtn.textContent = '...';
          await fetch(API + '/sessions/' + s.thread_ts, {
            method: 'DELETE', credentials: 'same-origin',
          });
          refreshState();
        });
        row.appendChild(killBtn);
        frag.appendChild(row);
      }

      if (active > 0) {
        const killAll = el('button', {class: 'kill-all-btn'}, 'Terminate All');
        killAll.addEventListener('click', async () => {
          killAll.disabled = true;
          killAll.textContent = '...';
          await fetch(API + '/sessions', {
            method: 'DELETE', credentials: 'same-origin',
          });
          refreshState();
        });
        frag.appendChild(killAll);
      }
      container.replaceChildren(frag);
    } else {
      container.replaceChildren(el('div', {class: 'empty'}, 'No CLI sessions'));
    }
  }
}

async function connectSSE() {
  if (currentSSE) {
    currentSSE.close();
    currentSSE = null;
  }

  // Start from the latest event so we only see new events going forward
  let startId = 0;
  try {
    const state = await fetchJSON('/state');
    if (state && state.latest_event_id) startId = state.latest_event_id;
  } catch { /* fall back to 0 */ }

  let sseUrl = API + '/events?last_id=' + startId;
  if (isRemoteMode() && authToken) {
    sseUrl += '&token=' + encodeURIComponent(authToken);
  }
  const es = new EventSource(sseUrl, isRemoteMode() ? {} : {withCredentials: true});
  currentSSE = es;

  es.onmessage = (e) => {
    eventCount++;
    document.getElementById('events-summary').textContent = String(eventCount);
    try {
      const data = JSON.parse(e.data);
      const log = document.getElementById('event-log');
      // Convert UTC to local time — handle both +00:00 and Z suffixes
      let time = '';
      if (data.timestamp) {
        try {
          const ts = data.timestamp.replace(/\+00:00$/, 'Z');
          const d = new Date(ts.endsWith('Z') ? ts : ts + 'Z');
          time = isNaN(d.getTime()) ? (data.timestamp.split('T')[1] || '').substring(0,8)
            : d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
        } catch { time = (data.timestamp.split('T')[1] || '').substring(0,8); }
      }
      // Show rich event detail from data payload
      let detail = data.type || '--';
      if (data.data && typeof data.data === 'object') {
        const d = data.data;
        const parts = [];
        // Primary content
        if (d.text) parts.push(d.text.substring(0, 80));
        else if (d.directive_text) parts.push(d.directive_text.substring(0, 80));
        else if (d.message) parts.push(d.message.substring(0, 80));
        else if (d.description) parts.push(d.description.substring(0, 80));
        // Agent + model info
        if (d.agent_id || d.agent) parts.push('[' + (d.agent_id || d.agent) + ']');
        if (d.model) parts.push('(' + d.model + ')');
        // Status + outcome
        if (d.status) parts.push(d.status);
        if (d.outcome) parts.push(d.outcome);
        if (d.error) parts.push('ERR: ' + String(d.error).substring(0, 40));
        // Cost + tokens
        if (d.cost !== undefined) parts.push('$' + Number(d.cost).toFixed(4));
        if (d.tokens_in || d.tokens_out) parts.push((d.tokens_in||0) + '/' + (d.tokens_out||0) + ' tok');
        // Task + directive IDs
        if (d.directive_id) parts.push('dir:' + d.directive_id.substring(0, 8));
        if (d.task_id) parts.push('task:' + d.task_id.substring(0, 8));
        // Attempt info
        if (d.attempt) parts.push('attempt ' + d.attempt);
        if (d.pid) parts.push('pid:' + d.pid);
        if (parts.length) detail += ': ' + parts.join(' | ');
      }
      const detailSpan = el('span', null, detail);

      // Add clickable CLI badge when event has a thread_ts
      const threadTs = data.data && data.data.thread_ts;
      if (threadTs) {
        const badge = el('span', {class: 'event-cli-badge', title: 'Open thread ' + threadTs},
          'CLI:' + threadTs.split('.')[0]);
        badge.addEventListener('click', () => {
          chatPanel.classList.add('open');
          selectThread(threadTs);
        });
        detailSpan.appendChild(badge);
      }

      const row = el('div', {class: 'event-row'}, [
        el('span', {class: 'event-time'}, time),
        el('span', {class: 'event-source'}, data.source || '--'),
        detailSpan,
      ]);
      log.prepend(row);
      while (log.children.length > 50) log.removeChild(log.lastChild);
    } catch { /* ignore malformed events */ }
  };

  es.onerror = () => {
    if (currentSSE === es) {
      es.close();
      currentSSE = null;
      setTimeout(connectSSE, 5000);
    }
  };
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (currentSSE) currentSSE.close();
  if (abortController) abortController.abort();
});

// Attach event listeners to card headers
document.querySelectorAll('.card-header').forEach(header => {
  header.addEventListener('click', toggle);
  header.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      toggle(e);
    }
  });
});

// Wrap dashboard startup so it only runs after auth
let refreshInterval = null;
function startDashboard() {
  updateConnectionBadge();
  if (offlineMode) {
    document.getElementById('engine-status').textContent = 'Static Mode (no engine)';
    document.querySelector('.dot').style.background = 'var(--warning)';
    return;
  }
  refreshState();
  if (refreshInterval) clearInterval(refreshInterval);
  refreshInterval = setInterval(refreshState, 5000);
  connectSSE();
}

// Kick off auth check instead of auto-starting
initAuth();

// ---------------------------------------------------------------------------
// Chat Panel — view and interact with Slack threads
// ---------------------------------------------------------------------------

const chatToggle = document.getElementById('chat-toggle');
const chatPanel = document.getElementById('chat-panel');
const chatClose = document.getElementById('chat-close');
const chatMessages = document.getElementById('chat-messages');
const chatInput = document.getElementById('chat-input');
const chatSend = document.getElementById('chat-send');
const threadList = document.getElementById('thread-list');

let activeThreadTs = null;

chatToggle.addEventListener('click', () => {
  chatPanel.classList.toggle('open');
  if (chatPanel.classList.contains('open')) loadThreads();
});
chatClose.addEventListener('click', () => chatPanel.classList.remove('open'));

async function loadThreads() {
  if (offlineMode) {
    threadList.replaceChildren(el('div', {class: 'empty'}, 'Threads unavailable in static mode'));
    return;
  }
  try {
    const chatOpts = {credentials: 'same-origin'};
    if (isRemoteMode() && authToken) { chatOpts.headers = {'Authorization': 'Bearer ' + authToken}; chatOpts.credentials = 'omit'; }
    const resp = await fetch(`${API}/chat/threads`, chatOpts);
    const data = await resp.json();
    threadList.replaceChildren();
    if (!data.threads || data.threads.length === 0) {
      threadList.appendChild(el('div', {class: 'empty'}, 'No threads yet'));
      return;
    }
    for (const t of data.threads) {
      const btn = el('button', {
        class: 'thread-item' + (t.thread_ts === activeThreadTs ? ' active' : ''),
      });
      btn.appendChild(document.createTextNode(t.text.slice(0, 80) || '(empty)'));
      if (t.reply_count > 0) {
        btn.appendChild(el('span', {class: 'thread-count'}, ` (${t.reply_count})`));
      }
      btn.addEventListener('click', () => selectThread(t.thread_ts));
      threadList.appendChild(btn);
    }
  } catch { threadList.replaceChildren(el('div', {class: 'empty'}, 'Slack not connected')); }
}

async function selectThread(ts) {
  activeThreadTs = ts;
  document.querySelectorAll('.thread-item').forEach(b => b.classList.remove('active'));
  try {
    const threadOpts = {credentials: 'same-origin'};
    if (isRemoteMode() && authToken) { threadOpts.headers = {'Authorization': 'Bearer ' + authToken}; threadOpts.credentials = 'omit'; }
    const resp = await fetch(`${API}/chat/thread/${ts}`, threadOpts);
    const data = await resp.json();
    chatMessages.replaceChildren();
    for (const msg of data.messages || []) {
      const cls = msg.is_bot ? 'msg msg-bot' : 'msg msg-user';
      chatMessages.appendChild(el('div', {class: cls}, msg.text));
    }
    chatMessages.scrollTop = chatMessages.scrollHeight;
  } catch { chatMessages.replaceChildren(el('div', {class: 'empty'}, 'Failed to load thread')); }
}

chatSend.addEventListener('click', sendMessage);
chatInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});

async function sendMessage() {
  const text = chatInput.value.trim();
  if (!text) return;
  if (offlineMode) {
    chatMessages.appendChild(el('div', {class: 'msg msg-bot'}, 'Chat unavailable in static mode. Start the engine locally.'));
    chatInput.value = '';
    return;
  }

  chatInput.value = '';
  chatSend.disabled = true;
  chatMessages.appendChild(el('div', {class: 'msg msg-user'}, text));
  chatMessages.appendChild(el('div', {class: 'msg-searching'}, 'Thinking...'));
  chatMessages.scrollTop = chatMessages.scrollHeight;

  try {
    const sendHeaders = {'Content-Type': 'application/json'};
    if (isRemoteMode() && authToken) sendHeaders['Authorization'] = 'Bearer ' + authToken;
    const resp = await fetch(`${API}/chat/send`, {
      method: 'POST',
      headers: sendHeaders,
      body: JSON.stringify({message: text}),
      credentials: isRemoteMode() ? 'omit' : 'same-origin',
    });
    const data = await resp.json();
    // Remove "Thinking..." indicator
    const thinking = chatMessages.querySelector('.msg-searching');
    if (thinking) thinking.remove();
    chatMessages.appendChild(el('div', {class: 'msg msg-bot'}, data.response || '(no response)'));
    chatMessages.scrollTop = chatMessages.scrollHeight;
  } catch (err) {
    const thinking = chatMessages.querySelector('.msg-searching');
    if (thinking) thinking.remove();
    chatMessages.appendChild(el('div', {class: 'msg msg-bot'}, 'Error: ' + err.message));
  } finally {
    chatSend.disabled = false;
    chatInput.focus();
  }
}
</script>
</body>
</html>
